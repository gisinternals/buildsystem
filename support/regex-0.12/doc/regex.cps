\initial {$}
\entry {\code {$}}{18}
\initial {(}
\entry {\code {(}}{16}
\initial {)}
\entry {\code {)}}{16}
\initial {*}
\entry {\samp {*}}{10}
\initial {-}
\entry {\samp {-}}{13}
\initial {.}
\entry {\samp {.}}{9}
\initial {:}
\entry {\samp {:]} in regex}{14}
\initial {?}
\entry {\samp {?}}{11}
\initial {[}
\entry {\samp {[}}{13}
\entry {\samp {[:} in regex}{14}
\entry {\samp {[{\tt\hat}}}{13}
\initial {]}
\entry {\samp {]}}{13}
\initial {{\tt\char'173}}
\entry {\samp {{\tt\char'173}}}{12}
\initial {{\tt\char'174}}
\entry {\code {{\tt\char'174}}}{13}
\initial {{\tt\char'175}}
\entry {\samp {{\tt\char'175}}}{12}
\initial {{\tt\char43}}
\entry {\samp {{\tt\char43}}}{11}
\initial {{\tt\hat}}
\entry {\samp {{\tt\hat}}}{13}
\entry {\code {{\tt\hat}}}{18}
\initial {{\tt\indexbackslash }}
\entry {{\tt\indexbackslash }}{7}
\entry {\samp {{\tt\indexbackslash }}}{13}
\entry {\samp {{\tt\indexbackslash }'}}{21}
\entry {\code {{\tt\indexbackslash }(}}{16}
\entry {\code {{\tt\indexbackslash })}}{16}
\entry {\samp {{\tt\indexbackslash }`}}{21}
\entry {\samp {{\tt\indexbackslash }{\tt\char'173}}}{12}
\entry {\code {{\tt\indexbackslash }{\tt\char'174}}}{13}
\entry {\samp {{\tt\indexbackslash }{\tt\char'175}}}{12}
\entry {\samp {{\tt\indexbackslash }{\tt\gtr}}}{21}
\entry {\samp {{\tt\indexbackslash }{\tt\less}}}{21}
\entry {\samp {{\tt\indexbackslash }b}}{20}
\entry {\samp {{\tt\indexbackslash }B}}{20}
\entry {\samp {{\tt\indexbackslash }s}}{22}
\entry {\samp {{\tt\indexbackslash }S}}{22}
\entry {\samp {{\tt\indexbackslash }w}}{21}
\entry {\samp {{\tt\indexbackslash }W}}{21}
\initial {A}
\entry {\code {allocated \r {initialization}}}{26}
\entry {alternation operator}{13}
\entry {alternation operator and \samp {{\tt\hat}}}{18}
\entry {anchoring}{18}
\entry {anchors}{18}
\entry {Awk}{5}
\initial {B}
\entry {back references}{17}
\entry {backtracking}{10, 13}
\entry {beginning-of-line operator}{18}
\entry {bracket expression}{13}
\entry {\code {buffer \r {field, set by \code {re{\_}compile{\_}pattern}}}}{27}
\entry {\code {buffer \r {initialization}}}{26}
\initial {C}
\entry {character classes}{14}
\initial {E}
\entry {Egrep}{5}
\entry {Emacs}{5}
\entry {end-of-line operator}{18}
\entry {\code {end\penalty 10000{\spaceskip = 0pt{} }\r {in\penalty 10000{\spaceskip = 0pt{} }\code {struct\penalty 10000{\spaceskip = 0pt{} }re_registers}}}}{32}
\initial {F}
\entry {\code {fastmap \r {initialization}}}{26}
\entry {\code {fastmap{\_}accurate \r {field, set by \code {re{\_}compile{\_}pattern}}}}{27}
\entry {fastmaps}{30}
\initial {G}
\entry {Grep}{5}
\entry {grouping}{16}
\initial {I}
\entry {ignoring case}{35}
\entry {interval expression}{12}
\initial {M}
\entry {matching list}{13}
\entry {matching newline}{13}
\entry {matching with GNU functions}{27}
\initial {N}
\entry {\code {newline{\_}anchor \r {field in pattern buffer}}}{18}
\entry {nonmatching list}{13}
\entry {\code {not{\_}bol \r {field in pattern buffer}}}{18}
\entry {\code {num_regs\penalty 10000{\spaceskip = 0pt{} }\r {in\penalty 10000{\spaceskip = 0pt{} }\code {struct\penalty 10000{\spaceskip = 0pt{} }re_registers}}}}{32}
\initial {O}
\entry {open-group operator and \samp {{\tt\hat}}}{18}
\entry {or operator}{13}
\initial {P}
\entry {parenthesizing}{16}
\entry {pattern buffer initialization}{26}
\entry {pattern buffer, definition of}{24}
\entry {POSIX Awk}{5}
\initial {R}
\entry {\code {range \r {argument to \code {re{\_}search}}}}{28}
\entry {\code {re_registers}}{32}
\entry {\code {RE{\_}BACKSLASH{\_}ESCAPE{\_}IN{\_}LIST}}{3}
\entry {\code {RE{\_}BK{\_}PLUS{\_}QM}}{3}
\entry {\code {RE{\_}CHAR{\_}CLASSES}}{3}
\entry {\code {RE{\_}CONTEXT{\_}INDEP{\_}ANCHORS}}{3}
\entry {\code {RE{\_}CONTEXT{\_}INDEP{\_}ANCHORS \r {(and \samp {{\tt\hat}})}}}{18}
\entry {\code {RE{\_}CONTEXT{\_}INDEP{\_}OPS}}{3}
\entry {\code {RE{\_}CONTEXT{\_}INVALID{\_}OPS}}{3}
\entry {\code {RE{\_}DOT{\_}NEWLINE}}{3}
\entry {\code {RE{\_}DOT{\_}NOT{\_}NULL}}{4}
\entry {\code {RE{\_}INTERVALS}}{4}
\entry {\code {RE{\_}LIMITED{\_}OPS}}{4}
\entry {\code {RE{\_}NEWLINE{\_}ALT}}{4}
\entry {\code {RE{\_}NO{\_}BK{\_}BRACES}}{4}
\entry {\code {RE{\_}NO{\_}BK{\_}PARENS}}{4}
\entry {\code {RE{\_}NO{\_}BK{\_}REFS}}{4}
\entry {\code {RE{\_}NO{\_}BK{\_}VBAR}}{4}
\entry {\code {RE{\_}NO{\_}EMPTY{\_}RANGES}}{4}
\entry {\code {re{\_}nsub \r {field, set by \code {re{\_}compile{\_}pattern}}}}{27}
\entry {\code {re{\_}pattern{\_}buffer \r {definition}}}{24}
\entry {\code {re{\_}syntax{\_}options \r {initialization}}}{26}
\entry {\code {RE{\_}UNMATCHED{\_}RIGHT{\_}PAREN{\_}ORD}}{4}
\entry {\code {REG{\_}EXTENDED}}{35}
\entry {\code {REG{\_}ICASE}}{35}
\entry {\code {REG{\_}NEWLINE}}{36}
\entry {\code {REG{\_}NOSUB}}{35}
\entry {\code {regex.c}}{1}
\entry {\code {regex.h}}{1}
\entry {regexp anchoring}{18}
\entry {\code {regmatch{\_}t}}{39}
\entry {\code {regs{\_}allocated}}{32}
\entry {\code {REGS{\_}FIXED}}{33}
\entry {\code {REGS{\_}REALLOCATE}}{32}
\entry {\code {REGS{\_}UNALLOCATED}}{32}
\entry {regular expressions, syntax of}{2}
\initial {S}
\entry {searching with GNU functions}{28}
\entry {\code {start \r {argument to \code {re{\_}search}}}}{28}
\entry {\code {start\penalty 10000{\spaceskip = 0pt{} }\r {in\penalty 10000{\spaceskip = 0pt{} }\code {struct\penalty 10000{\spaceskip = 0pt{} }re_registers}}}}{32}
\entry {\code {struct re{\_}pattern{\_}buffer \r {definition}}}{24}
\entry {subexpressions}{16}
\entry {syntax bits}{2}
\entry {\code {syntax \r {field, set by \code {re{\_}compile{\_}pattern}}}}{27}
\entry {syntax initialization}{26}
\entry {syntax of regular expressions}{2}
\initial {T}
\entry {\code {translate \r {initialization}}}{26}
\initial {U}
\entry {\code {used \r {field, set by \code {re{\_}compile{\_}pattern}}}}{27}
\initial {W}
\entry {word boundaries, matching}{20}
